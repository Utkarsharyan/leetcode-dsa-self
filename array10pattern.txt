==============================
PATTERN: Kadane’s Algorithm
PROBLEM: Maximum Subarray Sum
==============================

PROBLEM STATEMENT:
Given an integer array (can contain negative numbers),
find the contiguous subarray with the maximum sum.

Example:
arr = [-2,1,-3,4,-1,2,1,-5,4]
Output = 6
Explanation: Subarray [4, -1, 2, 1]

--------------------------------
BRUTE FORCE APPROACH (Naive)
--------------------------------
Idea:
Check all possible subarrays and calculate their sums.

Steps:
1. Fix a starting index i
2. Fix an ending index j (j >= i)
3. Calculate sum of subarray from i to j
4. Track the maximum sum seen

Time Complexity:
O(n^3) (two loops + sum calculation)
Optimized brute force with running sum:
O(n^2)

Space Complexity:
O(1)

Why this is inefficient:
- Too many overlapping subarrays
- Repeated sum calculations

--------------------------------
OPTIMIZED APPROACH (Key Insight)
--------------------------------
If a subarray sum becomes negative,
it will only reduce the sum of any future subarray.

So:
- A negative sum should be discarded
- Start fresh from the next element

This greedy insight leads to Kadane’s Algorithm.

--------------------------------
PATTERN EXPLANATION:
Kadane’s Algorithm
--------------------------------
Maintain two variables:
1. currentSum → maximum subarray sum ending at current index
2. maxSum → maximum subarray sum found so far

At each index:
- Either extend the previous subarray
- Or start a new subarray from current element

Formula:
currentSum = max(arr[i], currentSum + arr[i])
maxSum = max(maxSum, currentSum)

--------------------------------
DRY RUN EXAMPLE:
--------------------------------
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]

i   arr[i]  currentSum   maxSum
--------------------------------
0   -2      -2           -2
1    1       1            1
2   -3      -2            1
3    4       4            4
4   -1       3            4
5    2       5            5
6    1       6            6
7   -5       1            6
8    4       5            6

Answer = 6

--------------------------------
OPTIMIZED CODE (Java)
--------------------------------

static int maxSubArray(int[] arr) {
    int currentSum = arr[0];
    int maxSum = arr[0];

    for (int i = 1; i < arr.length; i++) {
        currentSum = Math.max(arr[i], currentSum + arr[i]);
        maxSum = Math.max(maxSum, currentSum);
    }

    return maxSum;
}

--------------------------------
TIME & SPACE COMPLEXITY
--------------------------------
Time Complexity: O(n)
Space Complexity: O(1)

--------------------------------
WHEN TO USE THIS PATTERN
--------------------------------
Use Kadane’s Algorithm when:
- Contiguous subarray
- Maximum or minimum sum required
- Array contains negative numbers

--------------------------------
COMMON INTERVIEW MISTAKES
--------------------------------
- Resetting sum to 0 blindly (fails for all-negative arrays)
- Confusing subsequence with subarray
- Forgetting to initialize with arr[0]

--------------------------------
LEETCODE QUESTIONS (Practice)
--------------------------------
1. Maximum Subarray
   LeetCode #53
   https://leetcode.com/problems/maximum-subarray/

2. Maximum Sum Circular Subarray
   LeetCode #918
   https://leetcode.com/problems/maximum-sum-circular-subarray/

--------------------------------
KEY TAKEAWAY
--------------------------------
If the running sum becomes harmful (negative),
drop it and start fresh.
Kadane’s is greedy + dynamic programming in disguise.
==============================
